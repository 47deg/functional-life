<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Section 11</title>
  <meta id="xcode-display" name="xcode-display" content="render">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, maximum-scale=1.0">
  <link rel="stylesheet" type="text/css" href="stylesheet.css">
</head>
<body>
<div class="content-wrapper">
  <section class="section">
    <p>These lines use <strong>optional binding</strong> to unwrap the values in the expressions: if the Swift runtime finds a nil value in the chain it will just stop and return a nil as a result for both expressions. We can also do a lot more with optionals using the next new tool in our arsenal.</p>
<h3 id="pattern-matching">Pattern matching</h3>
<p>Before Swift, we poor Objective-C programmers had limited <em>switch</em> blocks, that only allowed to check a scalar value or an enum against a set of values. It&#39;s not my intention to berate the good-old C switch blocks, but Swift has beefed them up to allow complex pattern matching in our day-to-day programming. Again this is nothing new to our functional languages: Scala and friends! With pattern matching, you can match a given value against a serie of conditions to return an specific result. This, combined with other elements of the language like tuples, optionals, and wildcards, gives us some powerful possibilities.</p>
<p>For example, let&#39;s discriminate between numbers. The next piece of code use pattern matching to distinguish between small, medium and big numbers. That alone could have been done with a simple if-else block, but things would get a little more complicated if we add more conditions. We really want to know if our numbers are <strong>cool</strong>, because as Yoda says: size matters not (at least with numbers!). With pattern matching is easy to check for classic coolness factors like being a prime number:</p>

  </section>
</div>
</body>
</html>
