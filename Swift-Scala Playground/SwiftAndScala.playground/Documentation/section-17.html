<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Section 18</title>
  <meta id="xcode-display" name="xcode-display" content="render">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, maximum-scale=1.0">
  <link rel="stylesheet" type="text/css" href="stylesheet.css">
</head>
<body>
<div class="content-wrapper">
  <section class="section">
    <p>What we&#39;ve done here is to add a new parameter <em>function</em> that, as you may imagine, takes a function. Specifically one that takes one Int as argument and returns a Bool. That way we can easily pass further math properties to our function without having to rewrite it each time:</p>
<pre><code>discriminateNumberByFunction(8, &quot;prime&quot;, isPrime)   // &quot;This is a really small number&quot;
discriminateNumberByFunction(5, &quot;prime&quot;, isPrime)   // &quot;This is a small but cool prime number&quot;
</code></pre><p>Do you remember the isPrime function we wrote earlier? As it took an Int and returned a Bool, we just have to pass it to our improved function and it just works right out the box! We can complicate things a little bit more:</p>
<pre><code>func isPerfectNumber(x: Int) -&gt; Bool {
    let max = Int(sqrt(Double(x))) + 1
    var total = 1

    func acumulator(x: Int, i: Int) {
        if x % i == 0 {
            total += i
            let q = x / i
            if q &gt; i {
                total += q
            }
        }
    }

    for i in 2..&lt;max {
        acumulator(x, i)
    }        
    return total == x
}

discriminateNumberByFunction(6, &quot;perfect&quot;, isPerfectNumber)      // &quot;This is a small but cool perfect number&quot;
discriminateNumberByFunction(28, &quot;Perfect&quot;, isPerfectNumber)    // &quot;Perfect class hero is something to be...&quot;
discriminateNumberByFunction(47, &quot;perfect&quot;, isPerfectNumber)    // &quot;Best number EVER&quot;
</code></pre><p>The function above calculates if a value is a perfect number (a positive number which is the sum of all its positive divisors excluding itself, the definition of coolness itself!). The code above uses some of the powerful things we can do now with functions in Swift. First: we have a function <em>acumulator</em> inside the function itself, which is rather cool until we notice the fact that it&#39;s modifying the scope outside its boundaries... (notice how it&#39;s accumulating values on <em>total</em> which exists outside it). Nested functions have access to their outside scope, and their container functions can even return them so they can be accessed by other functions. Now that&#39;s versatility! </p>
<p>(As a side nerdy note, until 2013 there were <strong>47</strong> known perfect numbers. Since 2014 there are 48, I guess they got main-stream now... :P)</p>
<p>In Objective-C, by using the infamously cumbersome block syntax, we could create pieces of executable code that worked as anonymous methods. Swift allows us to do the same with closures: </p>
<pre><code>discriminateNumberByFunction(8, &quot;Even&quot;, { (value: Int) -&gt; Bool in return value % 2 == 0})
discriminateNumberByFunction(8, &quot;Even&quot;, {$0 % 2 == 0})
discriminateNumberByFunction(8, &quot;Even&quot;) {$0 % 2 == 0}
</code></pre><p>So if we have a function that takes a function as a parameter, we can directly pass it a piece of code with the same signature. Swift allows us to write closures <a href="http://fuckingswiftblocksyntax.com/">in many different ways</a>, more or less verbosely depending on our needs. Above you can see three ways to pass a closure to our function so we can discriminate even and odd numbers. Notice how if we have a closure as the final parameter in a function call, we can write it as a trailing closure by having the curly braces outside the call itself! Also notice how we can omit the <strong>return</strong> statements (they&#39;re implied for the last line of the closure), and we can also use shorthands for our closure input parameters ($0, $1,... $n).</p>
<p>Again this is really close to the way Scala and other languages handle closures, and even the syntax is almost the same:</p>
<pre><code>// Scala: 
val maxNumber: (Int, Int) =&gt; Int = (m: Int, n: Int) =&gt; if(m &gt; n) m else n

// Swift:
let maxNumber = { (m: Int, n: Int) -&gt; (Int) in m &gt; n ? m : n }
maxNumber(3, 5)
</code></pre><h3 id="partially-applied-functions">Partially applied functions</h3>
<p>Partially applied functions (or curried functions) are the bread and butter of more functional languages like Scala, but at least for me (and I guess many programmers with almost no functional experience) is a rather new concept. Imagine you have a function that takes two Strings and join them together in a new String, like the following trivial one:</p>
<pre><code>func sayHelloToPerson(greeting: String, name: String) -&gt; String {
    return greeting + &quot;, &quot; + name
}

sayHelloToPerson(&quot;Hello&quot;, &quot;Dolly&quot;)    // &quot;Hello, Dolly&quot;
</code></pre><p>But what if we needed to greet in different languages, or use a more informal tone? Should be we writing different calls with &quot;Hi&quot; or &quot;Hola&quot; every time? It&#39;d be great to be able to define a default value for the first parameter in run-time, so we only needed to provide the name of the person to be greeted. We can do this with what&#39;s called a <strong>curried function</strong>: instead of taking two Strings and an Int, we&#39;re going to rewrite it so the function now takes a String as a parameter (the greeting), and returns a function that takes <em>another</em> String as a parameter (the name), and subsequently returns a String (the final greeting):</p>
<pre><code>func greetPerson(greeting: String)(name: String) -&gt; String {
    return greeting + &quot;, &quot; + name
}

let informallyGreet = greetPerson(&quot;Hi&quot;)
informallyGreet(name: &quot;Dolly&quot;)  // &quot;Hi, Dolly&quot;

let japaneseGreet = greetPerson(&quot;こんにちは&quot;)
japaneseGreet(name: &quot;Dollyさん&quot;)  // &quot;こんにちは, Dollyさん&quot;
</code></pre><p>This may not seem like a big deal: we&#39;re just setting up default values. But currying allows us to have functions that don&#39;t need all their input parameters in a certain moment to build their results (they&#39;ll be stored until all of them are available). And it&#39;s really easy to create curried functions from existing ones should we need it:</p>
<pre><code>func curriedlyDiscriminateNumberByFunction(functionDescription: String, function: (Int) -&gt; Bool)(x: Int) -&gt; String {
    return discriminateNumberByFunction(x, functionDescription, function)
}

let discriminateByPrimes = curriedlyDiscriminateNumberByFunction(&quot;prime&quot;, isPrime)
discriminateByPrimes(x: 3)  // &quot;This is a small but cool prime number&quot;
</code></pre><h3 id="higher-order-functions">Higher-order functions</h3>
<p>Having closures around sure helped to fix a big hole in Objective-C&#39;s collection types: the lack of 3 basic higher-order sequence functions that are supported by many other languages: Map, Filter and Reduce. These address common operations on collections and allows us to do some powerful stuff with few lines of code. Let&#39;s take a closer look to each one of them</p>
<p><strong>Map</strong>: allows us to create take every item in a collection, apply a function to it, and return a new collection with the transformed values. We have done it so many times in the past it&#39;s almost automatic to start writing a for-each loop... Not anymore!</p>
<pre><code>let beatles = [&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;]

// The old way:
var temp = [String]()
for beatle in beatles {
    temp.append(&quot;Good morning, \(beatle)&quot;)
}

// The brand-new-best way:
let beatGreetings = beatles.map({&quot;Good morning, \($0)&quot;})
// Good morning, John
// Good morning, Paul
// Good morning, George
// Good morning, Ringo
</code></pre><p>As you see, Swift&#39;s brief closure syntax is really handy here, specially the use of shorthand values. Map (and the other higher-order functions) also makes a good partnership with curried functions:</p>
<pre><code>let beatInformalGreetings = beatles.map(greetPerson(&quot;Good morning&quot;))
// Good morning, John
// Good morning, Paul
// Good morning, George
// Good morning, Ringo
</code></pre><p><strong>Filter</strong>: allows us to, well, filter a collection by applying a condition to each element. As all our previous closures, shorthand syntax makes it really comfy to apply conditions to our elements:</p>
<pre><code>let coolestBeatle = beatles.filter({$0 == &quot;Ringo&quot;})   // Everybody loves Ringo...
println(coolestBeatle)
</code></pre><p><strong>Reduce</strong>: reduce won&#39;t return a collection but a single value containing the result of applying a function to all elements of the collection. We need to pass two parameters to it (as opposed to <em>map</em> and <em>filter</em> that only take one), the first being the initial value for the calculation and the latter the function to apply. The most easy to imagine example of this would be a summatory function applied to an array of Int (with an initial value of 0). But we can use reduce with all kind of elements:</p>
<pre><code>let beatleMath = beatles.map({count($0)}).reduce(0, combine: +)    // 19
let beatleGreetings = beatInformalGreetings.reduce(&quot;&quot;, combine: {$0 + &quot;\n&quot; + $1 })
// Good morning, John
// Good morning, Paul
// Good morning, George
// Good morning, Ringo
</code></pre><p>In the first example we create an array containing the lengths of each beatle name (using <em>map</em>), and then calculating the sum of them all with <em>reduce</em>. In this case we don&#39;t need any fancy logic, so we can just pass the operator and forget about writing a closure. In the second example we&#39;re getting the informal greetings we crafted earlier, and concatenating them with a line-break between each; so we need a closure now. Again, the syntax for these higher-order functions is almost exact to Scala&#39;s (but the latter uses &quot;_&quot; as a shorthand operator, instead of Swift&#39;s $0, $1...).</p>
<p>Why don&#39;t you give it a try and experiment a little bit with these functions?</p>
<pre><code>let fullBeatles = [&quot;John Lennon&quot;, &quot;Paul McCartney&quot;, &quot;George Harrison&quot;, &quot;Ringo Starr&quot;, &quot;Brian Epstein&quot;, &quot;Stuart Sutcliffe&quot;, &quot;Pete Best&quot;]
// Get a list of all former Beatles&#39; surnames!
// Hint: use the map function to return a substring, you can use the find function to get the index of the separator...

let queenMembers = [&quot;Mercury&quot;, &quot;May&quot;, &quot;Deacon&quot;, &quot;Taylor&quot;]
// Try to concatenate all Queen members surnames that start with an &quot;M&quot;. Notice that in Swift you have the handy startsWith function!
// You can use filter and reduce, or use reduce alone itself.
</code></pre><p>These higher-order functions gives us so many different approaches to solve problems! In fact, both <a href="http://robnapier.net/reduction-in-force">filter and map are actually based on reduce</a>. Once you get the hang of them, you&#39;ll find yourself improving their use in your code really quickly!</p>
<h3 id="an-application-of-all-this-functional-life">An application of all this: Functional Life</h3>
<p>I thought it&#39;d be great to create a little app that would use some of these new functionalities. So I remembered <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway&#39;s Game of Life</a>: a nice little algorithm that sparked my imagination when I was a child and tried it on my brother&#39;s MSX computer (and it created a frenzy among micro-computer users in the 1970s and 80s). In &quot;Game of Life&quot; there&#39;s a field polluted with living and dead cells. The player creates a seed of life (made of several living cells), and then sees how it evolves generation by generation. Besides being a problem really fun to work in and having very visual results, I didn&#39;t realize that it&#39;s a pure functional problem: each generation is the result of applying the algorithm on its predecessor. It&#39;s like being the god of your own little universe, and not just some god but a <strong>functional one</strong>!</p>
<p>The project itself is an iPhone app, and the graphics and game loop are done using SpriteKit. You can find the game algorithm in the class FLGameAlgorithm, which you&#39;ll see it&#39;s really short and succinct. During the development I&#39;ve tried to use the features I&#39;ve introduced in the rest of the article, but as a newbie myself in the functional arena, I&#39;m sure there&#39;s a lot of room for improvement here. Advices and suggestions will be really appreciated! :). Feel free to download it from this repository ** TODO: put correct github repository url here.</p>
<h3 id="conclusion-at-last-">Conclusion (at last!)</h3>
<p>In this article I&#39;ve tried to share a little bit of my experience applying my basic knowledge of functional programming and patterns to my day-to-day Swift development. I&#39;d like to clarify that by no means I&#39;m trying to say that Swift is a functional language: while some of its features allow functional programming to be possible in Mac OS X and iOS development, there are really good arguments against this reasoning (i.e.: the clear and succinct <a href="http://robnapier.net/swift-is-not-functional">&quot;Swift Is Not Functional&quot;</a> by <a href="https://twitter.com/cocoaphony">@cocoaphony</a>). There&#39;s still many features from Scala, Haskell and all the other members of the functional family that are missing from Swift. But that&#39;s something I&#39;m sure the open-source community, and ourselves, are willing to help with! I hope that this text helps some of our fellow iOS/Mac developers to put a little of functional adventure into their routine imperative lives!</p>

  </section>
</div>
</body>
</html>
